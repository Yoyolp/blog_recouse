---
title: C语言学习笔记
---

C 语言学习笔记

<!--more-->

## 贪吃蛇游戏实现
### 定义全局变量&宏定义
蛇的地图使用一个2维uint数组实现，蛇头坐标使用 一个uint类型的变量表示，将uint 的高8位设定为y，低8位设定为x，同时蛇的方向，





<!-- ## 实践
环境：ubuntu-gcc13.3.0, WSL-Ubuntu, gdb15.0.50

有如下游戏代码 `snake_liunx.c`

```c
#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>

#define MAP_WIDTH   11
#define MAP_HEIGHT  11
#define GETPOS_X(pos) (pos & 0xffff)
#define GETPOS_Y(pos) (pos >> 16 & 0xffff)
#define SETPOS(x, y) (y << 16 | x)

#define TARGET_FPS 60.0
#define FRAME_TIME_MS (1000.0 / TARGET_FPS)
#define FRAME_TIME_US (FRAME_TIME_MS * 1000.0)

typedef struct _GameTimer
{
  struct timespec start_time;
  struct timespec end_time;
  double delta_time;
  int frame_count;
} GameTimer;

void init_timer(GameTimer* timer)
{
  clock_gettime(CLOCK_MONOTONIC, &timer->start_time);
  timer->delta_time = .0;
  timer->frame_count = 0;
}

void start_frame(GameTimer* timer) {
  clock_gettime(CLOCK_MONOTONIC, &timer->start_time);
}

void end_frame(GameTimer* timer) {
  clock_gettime(CLOCK_MONOTONIC, &timer->end_time);
  
  // 计算帧时间（秒）
  timer->delta_time = (timer->end_time.tv_sec - timer->start_time.tv_sec) +
                     (timer->end_time.tv_nsec - timer->start_time.tv_nsec) / 1e9;
  
  // 帧率限制
  double frame_time_ms = timer->delta_time * 1000.0;
  if (frame_time_ms < FRAME_TIME_MS) {
    double sleep_time_ms = FRAME_TIME_MS - frame_time_ms;
    usleep(sleep_time_ms * 1000); // 微秒单位
  } 
  timer->frame_count++;
}

unsigned int MAP[MAP_HEIGHT][MAP_WIDTH] = { 0 };
int SNAKE_DIRECTIONS[4][2] =
{ // 上， 下， 左， 右 [x, y] 
  {0, -1},
  {0, 1},
  {-1, 0}, 
  {1, 0}
};

unsigned int snake_pos = 0;
unsigned int direction = 0;
unsigned int score = 0;
unsigned int snakeLen = 4;
unsigned int applePos = 0;

// Linux 终端设置函数
static struct termios old_termios, new_termios;

void init_terminal(void) {
    tcgetattr(STDIN_FILENO, &old_termios);
    new_termios = old_termios;
    new_termios.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &new_termios);
}

void reset_terminal(void) {
    tcsetattr(STDIN_FILENO, TCSANOW, &old_termios);
}

// Linux 非阻塞输入函数
int kbhit(void) {
    struct timeval tv = {0L, 0L};
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    return select(1, &fds, NULL, NULL, &tv) > 0;
}

int getch_non_blocking(void) {
    if(kbhit()) {
        int r;
        unsigned char c;
        if((r = read(STDIN_FILENO, &c, sizeof(c))) < 0) {
            return r;
        } else {
            return c;
        }
    }
    return -1;
}

void init(void)
{
  snake_pos = SETPOS((int)(MAP_WIDTH / 2), (int)(MAP_HEIGHT / 2));
  direction = 0;
  score = 0;
  srand(time(NULL));
  init_terminal(); // 初始化终端设置
}

int randomRandint(int Min, int Max)
{
  return rand() % (Max - Min + 1) + Min;
}

void reflashApplePos(void)
{
  int x, y;
  do {
    x = randomRandint(1, 9);
    y = randomRandint(1, 9);
  } while(MAP[y][x] != 0);
  applePos = SETPOS(x, y);
}

void updataMap(unsigned int map[MAP_HEIGHT][MAP_WIDTH]) // 应该是 updateMap
{
  for(size_t i = 0; i < MAP_HEIGHT; i++) {
    for(size_t j = 0; j < MAP_WIDTH; j++) {
      map[i][j] -= map[i][j] > 0 ? 1 : 0;
    }
  }
  
  // 先检查边界再移动
  int new_x = GETPOS_X(snake_pos) + SNAKE_DIRECTIONS[direction][0];
  int new_y = GETPOS_Y(snake_pos) + SNAKE_DIRECTIONS[direction][1];
  
  // 边界检查
  if(new_x <= 0 || new_x >= MAP_WIDTH - 1 || new_y <= 0 || new_y >= MAP_HEIGHT - 1) {
    return; // 碰到边界，游戏结束
  }
  
  // 判断是否吃到apple
  if((unsigned int)SETPOS(new_x, new_y) == applePos) {
    reflashApplePos();
    snakeLen++;
  }
  snake_pos = SETPOS(new_x, new_y);
}

void updataOfSnakePos(unsigned int pos)
{
  MAP[GETPOS_Y(pos)][GETPOS_X(pos)] = snakeLen + 1;
}

void printMap(void)
{
  // 清屏 - Linux 版本
  printf("\033[2J\033[H");
  
  for(size_t i = 0; i < MAP_HEIGHT; i++) {
    printf("|");
    for(size_t j = 0; j < MAP_WIDTH; j++) {
      if(MAP[i][j] == 0) {
        if(i == GETPOS_Y(applePos) && j == GETPOS_X(applePos)) {
          printf("@@");
          continue;
        }
        printf("  ");
      }
      else if(MAP[i][j] > 0) {
        printf("##");
      }  
    }
    printf("|\n");
  }
}

int main(void)
{
  GameTimer timer;
  init_timer(&timer);
  init();

  reflashApplePos();
  
  int frame_counter = 0;
  bool game_running = true;
  
  while(game_running)
  {
    start_frame(&timer);

    // Game Key
    char keyInput = (char)getch_non_blocking();
    switch (keyInput) {
      case 'a': case 'A':
        if(direction != 3) direction = 2; break; // 不能直接反向
      case 'w': case 'W':
        if(direction != 1) direction = 0; break;
      case 's': case 'S':
        if(direction != 0) direction = 1; break;
      case 'd': case 'D':
        if(direction != 2) direction = 3; break;
      case 'q': case 'Q': // 退出游戏
        game_running = false;
        break;
    }

    printMap();

    frame_counter++;
    if(frame_counter >= 5) {
      frame_counter = 0;
      updataOfSnakePos(snake_pos);
      updataMap(MAP);
    }
  
    // 改进的边界检查
    int snake_x = GETPOS_X(snake_pos);
    int snake_y = GETPOS_Y(snake_pos);
    if(snake_x <= 0 || snake_x >= MAP_WIDTH - 1 || snake_y <= 0 || snake_y >= MAP_HEIGHT - 1) {
      game_running = false;
    }
  
    end_frame(&timer);

    double fps = 1.0 / timer.delta_time;
    printf("FPS: %.2f \t KEY:%c \t %d\n", fps, keyInput, direction);
    printf("x:%d \t y: %d \n", GETPOS_X(snake_pos), GETPOS_Y(snake_pos));
    printf("count:%d \t Score: %d\n", frame_counter, snakeLen - 4);
    printf("Press 'Q' to quit\n");
  }
  
  reset_terminal(); // 恢复终端设置
  printf("Game Over! Final Score: %d\n", snakeLen - 4);
  return 0;
}
```

> gcc -g ./snake_liunx.c -o ./snake_liunx
```gdb
Ctrl x, a
shell clear
Ctrl l
layout next
layout prev
Ctrl x, a
tui enable
tui disable

start
b init
set snakeLen = 100

``` -->



