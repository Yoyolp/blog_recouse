---
title: Program01
---
<!--more-->

## 内存分配问题

在多个程序内存分配上，存在许多内存的分配问题

+ 地址空间不隔离
+ 内存使用效率低
+ 内存运行的地址不稳定

### 虚拟地址

为了解决 如何将计算机上有限的物理内存分配给多个程序使用。

即由于计算机内存中的空闲空间地址，不是一成不变的，程序每次运行的时候我们都需要给它从内存中分配一块足够大的空间，
而在程序编写中，器访问的数据和地址很逗都是固定的，
所以通过添加中间层，间接访问地址的方式，即将程序给出的地址视为一种**虚拟的地址**，虚拟的地址通过一定的映射方法，转化成实际的物理地址
就可以保证任意一个程序所能访问的物理内存区域跟另外一个程序选规划不重叠，达到地址空间隔离的效果

### 分页

使用虚拟地址的方式，还不能解决内存使用效率低的问题，果果内存不足，被换入和换出到磁盘的都是整个程序，会造成大量访问磁盘的操作，从而严重影响速度

但是根据程序的局部性原理，当一个程序运行的时候他只是频繁运用到了一小部分数据，于是人们就想到了更小粒度的内存分割和映射的方法，大大提高了内存的使用率，这种放就是分页

枫叶的基本方法就是把地址空间认为的分成固定大小的页，每一页大小都由硬件决定，或者硬件支持多种大小的页，操作系统决定页的大小。但是在同一个时刻只能选择一种大小，但是目前市面上PC上操作系统
都使用**4KB**大小的页，如果一个计算机拥有 4GB的内存空间 那么理论上他会拥有大约104W的分页

## 原子操作

单指令操作不会执行一般被调度系统打断，去执行别的代码

## 同步与锁

为了避免多个线程同时读写统一数据而产生不可预料的后果，我们需要将各个线程对于同一个数据的访问**同步** ，即一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。对数据的访问被原子化了

同步最常见方法是使用**锁**，锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取锁 并在访问结束后释放锁，在锁已经被占用的时候视图获取锁的时候，线程会等待，知道锁重新可用

### 二元信号量

是最简单的一种锁，他只有两种状态: 占用与非占用。他事后只能被唯一一个线程独占访问的资源。当二元信号量处于非占用的状态时，第一额获取该二元信号量的线程或获得该锁，并将二元
信号重置为占用状态，第一个试图获取该二元信号量的线程将会等待，知道该锁被释放

对于允许多个线程访问的资源，多元信号量简称信号量，他是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候实现获取信号量，进行如下操作：

+ 将信号量的值 -1
+ 如果信号量的值小于0， 则进入等待状态，否则继续执行
  访问完资源后，线程释放信号量，进行如下操作：
+ 将信号量的值 +1
+ 如果信号量的值小于1，唤醒一个等待中的线程

### 互斥量

和二元信号量很类似，资源仅同时允许一个线程访问，但是和信号量不同的是，信号量在整个系统中可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放，而互斥量要求哪个线程
获取的互斥量，哪个线程就要负责释放整个锁，其他线程释放这个互斥量是无效的

### 临界区

是比互斥量更加严格的同步手段，在术语中，把临界区的锁的获取称为离开临界区。临界区的作用范围仅限于本线程，其他的进程无法获取该锁，除此之外临界区有何互斥区相同的性质。

### 读写锁

有两种获取方式：

+ 共享的
+ 独占的

### 条件变量

## 函数重入

一个函数的重入，表示这个函数没有执行完成，由于外部因素或者内部调用，又一次进入该函数执行。一个韩式要被重入，只有两种情况：

+ 多个线程同时执行这个函数。
+ 函数自身（可能式经过多层调用之后）调用自身

一个函数被重入之后不会产生任何不良后果。举个例子：

```c
int sqr(int x) 
{
  return x * x;
}
```

一个函数要成为可重入的，必须要具有如下几个特点：

+ 不使用任何（局部）静态或全局的非 `const` 变量
+ 不范围任何（局部）静态或全局的非 `const` 变量的指针
+ 仅依赖于调用方提供的参数。
+ 不依赖任何单个资源的锁
+ 不调用任何不可重入的函数

可重入式并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用

## gcc 编译过程

当我们使用 GCC 来编译程序的时候，编译器将会有4中编译的过程

```text
预处理 -> 编译 -> 汇编 -> 链接
```

### 预编译

预编译过程中主要是处理那些源代码文件中的预编译指令，删除所有注释，保留 #pragma 编译器指令
经过编译的.i 文件不包含任何宏定义，因为所有宏定义已经被展开，并且包含的文件也被插入到.i 文件中

### 编译

编译过程就是将把预处理完的文件进行一系列此法分析语法分析。语义分析以及优化后生产相应的汇编代码文件

### 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令

### 链接

找到所有变量和函数的引用所对应的定义。为所有代码和数据分配运行时内存地址，并修正指令中的地址。
链接库文件， 将库的代码完整赋值到你的最终可执行文件中，即合并目标文件

链接的过程中主要包括了：地址和空间分配，符号决议，重定位等这些步骤

#### 重定位

由于在编译目标文件的时候编译器不知道变量var的目标地址，所以编译器在没有变法确定地址的情况下会把这个指令的地址福分修改成0x10000.这个地址修正的过程也被叫做重定位

### 词法分析

词法分析产生的记号一般可以分为如下几类：关键字，标识符，字面量（数字。字符串 ）和特殊符号：（+，=），将标识符放到符号表，将数字，字符串常量放到文字表

### 语法分析

对由扫描器产生的记号进行语法分析，从而产生语法树，有语法分析器产生的语法树就是以表达式为节点的数

### 语义分析

进行语法层面的分析，分析语句是否合法，**静态语义** 是指可以在编译期就可以确定的语义，与之相对应的**动态语义**

静态语义通常包括声明和类型的匹配，类型的转化。比如当一个浮点型的表达式赋值给一个整型表达式的时候，其中隐含了一个浮点型到整形的转化过程
但是如果将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般指指在运行期间出现语义相关的问题，比如将0作为除数

### 中间语言的生成

中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，而编译器后端将中间代码转化成目标机器代码，这样对于一些可以跨平台的编译器而言，他们可以正对不同平台使用同一个前端和针对不同机器平台的数个后端

### 目标代码的生成和优化

源码级优化器产生的中间代码标志着代码标着下面的过程中都属于编辑器的后端。编译器后端只要包括**代码生成器**和**目标代码生成器**。让我们先来看看代码生成器。代码生成器将中间代码转化车目标机器码
。这个过程十分依赖目标机器，因为不同机器拥有不同的字长，寄存器，整数数据类型和浮点数据类型等。

## 目标文件的格式

现在PC平台流行的可执行文件格式，主要是 Windows 下的PE 和Liunx 下的ELF

从广义上来看目标文件与可执行文件的格式其实几乎一样的，所以我们可以广义的将目标文件与可执行文件堪称是一种类型的文件

不光是**可执行文件** 按照可执行文件格式存储。动态链接库（DLL）*（Windows 的 .dll; Liunx 的 .so）* *以及静态链接库(Windows 的lib 和 Linux 的 .so)* 文件都按照可执行文件储存

| ELF文件类型  | 说明                                                                                                                                                                                                                                         | 实例                                               |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |
| 可重定位文件 | 这类文件包含了代码和数据，可以被用个来链接成可执行文件或者共享目标文件，静态链接库也可以归为这一类                                                                                                                                           | Liunx : .o<br />Windows: .obj                      |
| 可执行文件   | 这类文件包含了可以直接执行的程序，他的代表就是ELF可执行文件，他们一般都没有扩展名                                                                                                                                                            | Liunx:.so (eg:glibc.so)<br />Windows : DLL         |
| 共享目标文件 | 这种文件包含了代码和数据，可以在以下两种情况下使用，一种是连接器可以使用这种文件更其他的可重定位文件和共享目标文件连接<br />产生新的目标文件，<br />第二种是动态连接器可以将即可这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 | Liunx ： .so (eg: glibc-2.5.so)<br />Windows : DLL |
| 核心转储文件 | 当进程意外终止时，系统可以将该进程的地址空间的地址空间的内容以及终止时的一些其他信息转储到核心转储文件                                                                                                                                       | Liunx下的core dump 中                              |

我们可以在 Linux 下使用 file 命令来查看相应的文件格式

## 目标文件的样式

程序源代码被编译以后主要分成两种阶段：程序指令和程序数据。代码段（.text）属于程序指令，而数据段 和.bss 段属于程序数据

指令和数据分开存储的重要原因

+ 程序装载后，数据和指令分别被映射到两个虚存区域。由于区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，这样可以防止程序的指令被有意或者无意地改写
+ 对于现代CPU来说，它们拥有极为强大的缓存体系。由于缓存在先到计算机中地位非常重要，错译程序必须提供缓存的命中率。而指令区和数据区的分离有利于程序的局部性
+ **当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份该程序的指令部分。**

### 代码段

通过objdump 我们可以通过"-h" 查看object 内部的结构

.text 主要存放文件的代码

**.bss, 只读数据段(.rodata) ，注释信息段(.comment) 和 堆栈提示段(.note.GUN-stack)**, 段具有 CONTENTS， ALLOC 等表示段的各种属性，其中CONTENTS 表示该段在文件中存在

如果我们看到一个段没有CONTENTS 这个属性那么 可以表示在实际的ELF 中不存在内容，同时有一种专门的**命令 ** `size`使得我们可以用来查看ELF 文件的代码段，数据段。和BSS段的长度

为了挖掘代码段内容，我们可以使用objdump 的 "-s" 参数将所有端的我内容按照十六进制的方式打印出来，"-d" 可以将所有包含指令的段反汇编

### 数据段和只读数据段

.data 段保存的是那些已经初始化了的全局变量和局部静态变量。 而.rodata  中存放的是只读数据，一般在程序里面的只读变量（如const 修饰的变量）和字符串常量，但是有时候编译器也会将这些数据存放到.data 段中

### BSS段

.bss 段存放的是未初始化的全局变量和局部静态变量

### 其他段

这是一些ELF文件中常用的段

| 常用的段名字     | 说明                                                                                     |
| ---------------- | ---------------------------------------------------------------------------------------- |
| .rodatal         | Read only Data 这种段中存放的只是制度数据，比如字符串常量，全局const 变量 跟 rodata 一样 |
| .comment         | 存放的是编译器版本信息 EG: "GCC:(GUN) 4.2.0"                                             |
| .debug           | 调试信息                                                                                 |
| .dynamic         | 动态链接信息                                                                             |
| .hash            | 哈希表                                                                                   |
| .line            | 调试时的行号表，即源代码行号与编译后指令的对应表                                         |
| .note            | 额外的编辑器信息，比如程序的公司名，发布的版本号                                         |
| .strtab          | String Table 字符串表，用于存储ELF 文件中用到的各种字符串                                |
| .symtab          | Symbol Table 符号表                                                                      |
| .shstrtab        | Section String Table 段名表                                                              |
| .plt<br />.got   | 动态链接的跳转表和全局入口表                                                             |
| .init<br />.fini | 程序的初始化和终结代码段                                                                 |

这些段的名字是 以"."作为前缀，表示这些表的名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名，但是程序自定义的段名不能够使用"." 作为前缀否则容易跟系统保留段名冲突。同时一个ELF文件可以拥有几个相同段名的段，比如一个ELF文件中可能由两个或者两个以上的叫做".text"的段。还有一些保留的段名是因为ELF的历史遗留问题造成的，以前用过的一些名字如.sdata .tdesc . sbss .lit4 .lit8 .reginfo .liblist .conflict 可以不必理会这些段，他们已经被遗弃了

### 将二进制文件比如图片，MP3 音乐 词典一类的东西作为目标文件中的一个段

可以使用objcopy工具， 比如我们有一个图片文件 "image.jpg" 大小为 0x82100 Bytes

```bash
objcopy -I binary -O elf32-i386 image.jpg image.o
objdump -ht image.o
```

符号 _binary_image_jpg_start, _binary_image_jpg_end 和 _binary_image_jpg_size 分别表示该图片文件在内存中的起始位置，结束位置和大小，我们可以在程序里面直接声明并使用他们

### 自定义段

正常情况下， GCC 编译出来的目标文件中，代码会被放到.text 段中，全局变量和静态变量也会放到对应的段中去，但是我们以可以通过 GCC 提供的一个**扩展机制**来指定一个变量所处的段
```c
__attribute__((section("FOO"))) int global = 42;
__attribute__((section("BAR"))) void foo()
{

}
```
在全局变量或者函数之前加上 `__attribute__((section("name")))` 属性就可以把相应的变量或者函数放到以"name" 作为段名的段中

