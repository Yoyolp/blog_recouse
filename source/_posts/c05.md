---
title: C语言学习笔记05
---
文件分类，文件系统，文件读写

<!--more-->

## 文件分类:

+ 普通文件
+ 设备文件 ： 把外部设备也看做一个一个文件来进行管理，把他们的输入，输出等同于对磁盘文件的读和写
+ 文件夹

#### 常见文本文件的编码:

* unicode: ff fe
* unicode-big: fe ff      <- 小段序
* utf-8: ef bb bf

## 文件系统：

文件系统指的是操作系统中用于组织和管理磁盘上文件的方法以及数据结构。文件系统负责为用户建立文件，存入。读出修改转储，控制等等

## 文本文件与二进制文件

文本文件基于字符编码，以固定长度的二进制序列以固定长度的二进制序列进行编码和解码，而二进制文件是基于值编码的文件，二进制文件是边长的，具体长度是由具体的格式决定的

，EXE or EMP 二进制文件夹

## 文件创建（打开）和关闭

我可以使用fopen())床架一个新的文件或者打开一个已有的文件，这个调用会初始化类型FILE 的一个对象，类型FILE 包含的用来控制流的必要信息

```c
FILE *fopen( const char *filename, const char *mode ); // 这是声明

int create_file()
{
  char *path = "d:\\docs\\mallocfree.txt";
  FILE* file = fopen(path, "w");
  if(file == NULL)
  {
    return -1;
  }

  fclose(file);
  return 0;
}


```

| 模式 | 表述                                                                                                                 |
| ---- | -------------------------------------------------------------------------------------------------------------------- |
| r    | 打开一个已有的文本文件，允许读取文件                                                                                 |
| w    | 打开一个文本文件，允许写入文件，如果文件不存在，则会创建一个新文件，在这里，您的程序会从文件的开头写入内容           |
| a    | 打开一个文本文件，以追加模式写入文件，如果文件不存在，则会创建一个新的文件，在这里，你的程序会在已有的文件中追加内容 |
| r+   | 打开一个文本文件，允许读写文件                                                                                       |
| w+   | 打开一个文本文件，允许读写文件。如果我呢见已经存在，则文件会被阶段为零长度，如果文件不存在，则会创建一个新的文件     |
| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新的文件。读取会从文件的开头开始，写入则只能是追加模式   |

如果处理的是二进制文件，则需要使用下面的访问模式来取代上卖弄的访问模式 加入",ccs=utf8" 可以改变读取文件所需要的编码

#### 支持的编码类型

| 参数值           | 说明                                |
| ---------------- | ----------------------------------- |
| "w,ccs=UNICODE"  | UTF-16LE 编码（Windows 默认 Unicode |
| "w,ccs=UTF-8"    | UTF-8 编码                          |
| "w,ccs=UTF-16LE" | UTF-16 小端序                       |
| "w,ccs=UTF-16BE" | UTF-16 大端序                       |

```c
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
```

为了关闭文件请使用fclose() 函数。函数的使用原型如下：

```c
int fclose(FILE *fp);
```

如果成功关闭文件，fclose() 函数返回0，如果关闭文件时发生错误，函数返回EOF。这个函数实际上，会清空缓冲区中的数据，关闭我呢见，并释放该文件中的所有内存

。EOF 是一个定义在头文件stdio.h 中的常量。

## 读写文件

### 打开文件

打开文件一般来说有如下两个实现方式,即使用 **fopen** 或者 **fopen_s**

```c
// 打开方式1
int create_file(char* filePath)
{
  FILE* file = fopen(filePath, "w");
  if(file == NULL) {
    int errCode = GetLastError();
    printf("err-file_create_failed: %d", errCode);
    return -1;
  }

  fclose(file);
  return 0;
}

//  打开方式2
int create_file2(char* filePath)
{
  FILE* file = NULL;
  errno_t err = fopen_s(&file, filePath, "w");

  if(err != 0 || file != NULL) {
    return -1;
  }

  fclose(file);

  return 0;
}
```

注意： 虽然在程序结束后系统会自动清理所有打开的文件，但是如果在使用 fopen 等 没有使用fclose 关闭文件的话，会浪费系统空间

### 二进制读写

在需要进行二进制读写的情况下，可以使用 fwrite 来写入文件 或者使用 fread 来读取二进制文件

```c
// 二进制文件读写
void binaryio_demo(void)
{
  char* filePath = ".\\binary_io.bin";
  FILE* file = NULL;

  errno_t err = fopen_s(&file, filePath, "wb");

  if(err != 0 || file == NULL) {
    printf("file write err!\n");
    goto demoEnd;
  }
  // 写入文件
  fwrite("Hello World", strlen("Hello World") + 1, 1, file);

  int data = 100;
  fwrite(&data, sizeof(data), 1, file);

  fclose(file);

  err = fopen_s(&file, filePath, "rb");  
  if(err != 0 || file == NULL) {
    printf("file read err!\n");

    goto demoEnd;
  }
  char buf[128] = { 0 };
  fread(buf, strlen("Hello World") + 1, 1, file);
  
  int value = 0;
  fread(&value, sizeof(value), 1, file);
  
  printf("buf: %s, value:%d\n", buf, value);

  fclose(file);

demoEnd:
  printf("demo end!\n");
}
```

### 格式化读写

在需要对文本文件进行进行格式化的读写时候可以 使用 fprintf 和 fscanf 这个两个函数，可以将文本格式化写入或者读出 文件

```c
void format_io(void)
{
  char* filePath = ".\\formart_io.txt";

  FILE* fp = NULL;

  errno_t err = fopen_s(&fp, filePath, "w");
  if(err != 0 || fp == NULL) {
    goto FORMAT_IO_END;
  }

  fprintf(fp, "%s %d", "Hello_World!", 100);
  fclose(fp);

  fp = NULL;
  err = fopen_s(&fp, filePath, "r");
  if(err != 0 || fp == NULL) {
    goto FORMAT_IO_END;
  }
  char buf[128] = { 0 };
  int value = 0;

  // 格式化输入
  fscanf(fp, "%s %d", buf, &value);

  printf("Format_io_printf: %s %d\n", buf, value);
  fclose(fp);

FORMAT_IO_END:
  printf("FORMAT IO END!\n");
}
```

#### C 语言标准输出流

在C 语言中 有3个预定义的标准流

| 流       | 文件指针 | 描述       |
| -------- | -------- | ---------- |
| 标准输入 | stdin    | 键盘输入   |
| 标准输出 | stdout   | 控制台输出 |
| 标准错误 | stderr   | 错误输出   |

所以我们的键盘 屏幕，也算是一种设备文件，可以被fprintf，fscanf等访问

eg:

```c
fprintf(stdout, "Hello World");
printf("Hello World");
```

是等效的

### 逐字符处理

在遇到需要逐个字符类处理的情况时，可以通过使用 fgetc fputc 来获取输入输出

```c
int char_io(void)
{
  char* str = "Hello World\0";
  char* filePath = ".\\char_io.txt";

  FILE* fp = NULL;
  errno_t err = fopen_s(&fp, filePath, "w");
  if(err != 0 || fp == NULL) {
    return -1;
  }
  while(*str != '\0') {
    fputc(*str, fp);
    str++;
  }
  fputc('\0', fp);
  
  fclose(fp);

  fp = NULL;
  err = fopen_s(&fp, filePath, "r");
  if(err != 0 || fp == NULL) {
    return -1;
  }

  while(!feof(fp)) {
    char ch = fgetc(fp);
    printf("%c", ch);
  }
  printf("\n");

  fclose(fp);

  return 0;
}
```

### 逐字符串处理

在遇到需要逐个字符串处理的情况时，可以通过使用 fgets fputs 来获取输入输出

```c
int str_io(void)
{
  char* data[4] = 
  {
    "hello world\n",
    "hello China\n",
    "hello Beijing\n",
    "Callioc ~\n"
  };

  char* filePath = ".\\str_io.txt";

  FILE *fp = NULL;
  errno_t err = fopen_s(&fp, filePath, "w");
  if(err != 0 || fp == NULL) {
    return -1;
  }

  for(int i = 0; i < 4; i++) {
    fputs(data[i], fp);
  }
  fclose(fp);

  fp = NULL;
  err = fopen_s(&fp, filePath, "r");
  if(err != 0 || fp == NULL) {
    return -1;
  }

  while(!feof(fp))
  {
    char buf[128] = { 0 };
    fgets(buf, 128, fp);
    printf("str_io:buf:%s", buf);
  }
  fclose(fp);

  return 0;
}
```




