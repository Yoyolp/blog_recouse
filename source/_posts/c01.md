---
title: C语言学习笔记
---

计算机存储数据大小 命名规范， 字符串，面向过程，面向对象区别,  函数传参
<!--more-->
# 常见数据类型大小
| 数据类型 | 大小(Byte) |
|:- |:-|
|char| 1 |
|short| 2 |
|int | 4|
|long| 4 & 8|
|float |4|
|double |8|

 
# int
### 整数编码
补码 负数绝对值取反+1

### 存储方式 小端序&大端序

# float & double
### 在IEEE标准中 符号域S(1bit) 阶码域E（8bit| 11bit）尾数域M(23bit|52bit)
### 值计算方法
$$
\text{值} = (-1)^S \times (1 + M) \times 2^{(E - \text{Bias})}
$$

|精度 | 指数偏置(Bias) | 尾数隐含位| 
|:-- |:-- |:-- | 
|单精度 | 127| 1.M|
| 双精度 | 1023 | 1.M | 

如何判断是否有隐含位?
如果
```text
if 指数 == 0: 隐含位 = 0
else:        隐含位 = 1
```

# 获取类型长度 - **sizeof**

# 强制类型转换，
从小到大转换的化，符号位填充多出来的位数，从大到小则是截断高位

# 隐式转换，
1. 如果表达式参与运算的变量类型不同，则现转化成同一个类型，然后进行运算，
2. 转化按数据长度增加的方向进行，以保证精度不降低。如int， long 型运算的时候，先把int->转换成long型计算
 + 如果两钟类型的字节数不同，转换成字节数高的类型
 + 若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号的类型
3. 所有的浮点运算都是以双精度进行的 在运算的时候如果是float 要转换成double 在运算

# 变量的命名规范：匈牙利命名法则
基本原则: 变量名=属性+类型+对象描述
|属性部分|类型部分|描述部分|
|:-|:-|:-|
|全局变量g_|指针p|最大MAX|
|常量c_|函数fn|最小MIN|
|c++类成员变量|无效v|初始化init|
|静态变量s_|长整型l|最大MAX|
||句柄h||
||长整型l||
||布尔型b||
||浮点型f||
||双字节dw||
||字符串sz||
||短整型n||
||双精度浮点d||
||计数c||
||整型i(n)||

eg:
```c
int g_nTotal = 0;
char m_chGender = "M";
char* szName = "Hello World";
bool blsOpened = false;
```

# 字符串定义
所谓字符串是由零个或者多个字符组成的有限数列。C语言字符串可以定义为
由引号包含由零个或者多个字符组成的有限序列。
## 多字节字符串和宽字节字符串
```c
char* str = "Hello_World_你好世界!";
wchar_t* wstr = L"Hello_World_你好世界!";

```
第一个是多字节字符串，其中英文字符串占一个字节，中文占两个字节，每个字符的编码宽度都不等
而第二个是一个宽字节字符串。其中每个字符，无论中英文字符还是结尾的(**\\0\0\\**)都占两个字节(**UNICODE**)
可以调用**wctomb()** 等函数将宽字符串和多字节串进行香花转换 

对于字符串可以使用函数**strlen()** 来计算他的长度，但是由于在C语言中 字符串是以**\\0** 结尾的
对于计算
```C
"Hello\0World"
```
的长度只会计算\0以前的长度

## 字符串API
对于字符串的API都有多字节和宽字节版本
 + strxxx
 + wcsxxx
 + _tcsxxx   (TCHAR)

### 字符串的API的实现

strlen, strcat,  实现
```c
// ===================================
size_t myStrlen(const char* str)
{
  size_t count = 0;
  while(*str != '\0') {
    count++;
    str++;
  }
  return count;
}

size_t myStrlen2(const char* str)
{
  const char* eos = str;
  while(*eos++);

  return (size_t)(eos - str - 1);
}

size_t myStrlen3(const char* str)
{
  return str == NULL || *str == '\0' ? 0 : 1 + myStrlen3(str + 1);
}
// ===========================

char* myStrcpy(char* dst, const char* src)
{
  char* s = dst;
  while (*s++ = *src++);
  // *s='\0';
  return dst;
}

// ====================================

int myStrcmp(const char* s1, const char* s2)
{
  assert(s1 != NULL && s2 != NULL);

  while (*s1 && *s2 &&(*s1 == *s2))
  {
    s1++;
    s2++;
  }
  return *s1 - *s2;

}

```


# 函数定义注意事项
 * 功能单一
 * 一般不超过200 行
 * 输入输出
 * 变量初始化
 * 严进宽出
 * assert 的使用
 * 时间与空间复杂度
 * 边界考虑
 * 函数功能测试
 * return 函数不能返回指向"栈内存"的"指针"或者"引用",因为该内存单元在函数体结束时被自动释放

# 函数传参
 + 传值: 形参是对实参值的一个拷贝，形参和实参是不相关的无法通过改变形参来改变实参
 + 传指针: 形参是对实参地址的一个拷贝，通过地址可以实现对于实参的修改
 + 传应用: 形参是对实参的一个**引用**,新参就是实参本身，改变形参就是改变实参本身(C++)


# 面向对象和面向过程的区别
面向是分析问题的解决步骤，然后用函数把这些步骤一步一步实现，然后在使用的时候一一调用即可

面向对象是把构成问题的事务分解成各个对象，建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事务在解决整个问题的过程中所发生的行为。

eg: 下雨的时候人们为了防止被雨淋打开伞避雨

面向过程：
下雨了，我打开了伞，挡雨
```TEXT
rain(雨)
open(我, 伞)
prevent(伞, 雨)
```

面向对象:
  + 对象: 我,伞 ,雨
  + 行为: 雨下， 我打开伞， 伞挡住雨
```TEXT
rain().fall()
me.open(unbrella)
umbrella.prevent(rain)
```

总结:

面向过程就是把问题分解成若干步骤，每个步骤实现一个函数，一步步实现，然后在使用的时候，把数据传递给这些函数，计算得出结果

面向对象是首先抽象出各种对象，把数据和解决的问题的方法封装在对象中，然后各个对象之间通过行为发生作用









